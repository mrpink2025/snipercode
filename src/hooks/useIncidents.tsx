import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { toast } from 'sonner';

export type IncidentSeverity = 'low' | 'medium' | 'high' | 'critical';
export type IncidentStatus = 'new' | 'in-progress' | 'blocked' | 'approved' | 'resolved';

export interface Incident {
  id: string;
  incident_id: string;
  host: string;
  machine_id: string;
  user_id: string;
  tab_url?: string;
  severity: IncidentSeverity;
  status: IncidentStatus;
  cookie_excerpt: string;
  full_cookie_data?: any;
  is_red_list: boolean;
  assigned_to?: string;
  resolution_notes?: string;
  created_at: string;
  updated_at: string;
  resolved_at?: string;
  // Joined data
  user?: {
    full_name: string;
    email: string;
  };
  assigned_user?: {
    full_name: string;
  };
}

interface UseIncidentsReturn {
  incidents: Incident[];
  loading: boolean;
  error: string | null;
  totalCount: number;
  createIncident: (data: Partial<Incident>) => Promise<void>;
  updateIncident: (id: string, updates: Partial<Incident>) => Promise<void>;
  deleteIncident: (id: string) => Promise<void>;
  refetch: () => Promise<void>;
}

interface UseIncidentsOptions {
  status?: IncidentStatus | 'all';
  severity?: IncidentSeverity | 'all';
  searchTerm?: string;
  limit?: number;
  offset?: number;
}

export const useIncidents = (options: UseIncidentsOptions = {}): UseIncidentsReturn => {
  const [incidents, setIncidents] = useState<Incident[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalCount, setTotalCount] = useState(0);
  const { profile } = useAuth();

  const { status, severity, searchTerm, limit = 50, offset = 0 } = options;

  const buildQuery = () => {
    let query = supabase
      .from('incidents')
      .select(`
        *,
        user:profiles!incidents_user_id_fkey(full_name, email),
        assigned_user:profiles!incidents_assigned_to_fkey(full_name)
      `, { count: 'exact' });

    // Apply filters
    if (status && status !== 'all') {
      query = query.eq('status', status);
    }

    if (severity && severity !== 'all') {
      query = query.eq('severity', severity);
    }

    if (searchTerm) {
      query = query.or(`host.ilike.%${searchTerm}%,incident_id.ilike.%${searchTerm}%,machine_id.ilike.%${searchTerm}%`);
    }

    // Ordering and pagination
    query = query
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    return query;
  };

  const fetchIncidents = async () => {
    try {
      setLoading(true);
      setError(null);

      const { data, error: queryError, count } = await buildQuery();

      if (queryError) {
        throw queryError;
      }

      setIncidents(data || []);
      setTotalCount(count || 0);
    } catch (err) {
      console.error('Error fetching incidents:', err);
      setError(err instanceof Error ? err.message : 'Erro ao carregar incidentes');
    } finally {
      setLoading(false);
    }
  };

  const createIncident = async (data: Partial<Incident>) => {
    try {
      if (!profile) {
        throw new Error('Usuário não autenticado');
      }

      const incidentData = {
        host: data.host || '',
        machine_id: data.machine_id || '',
        user_id: profile.id,
        tab_url: data.tab_url,
        severity: data.severity || 'medium' as IncidentSeverity,
        cookie_excerpt: data.cookie_excerpt || '',
        full_cookie_data: data.full_cookie_data,
        is_red_list: data.is_red_list || false,
        status: 'new' as IncidentStatus,
        incident_id: '' // Will be auto-generated by database trigger
      };

      const { error } = await supabase
        .from('incidents')
        .insert(incidentData);

      if (error) {
        throw error;
      }

      toast.success('Incidente criado com sucesso!');
      await fetchIncidents();
    } catch (err) {
      console.error('Error creating incident:', err);
      const message = err instanceof Error ? err.message : 'Erro ao criar incidente';
      toast.error(message);
      throw err;
    }
  };

  const updateIncident = async (id: string, updates: Partial<Incident>) => {
    try {
      const { error } = await supabase
        .from('incidents')
        .update(updates)
        .eq('id', id);

      if (error) {
        throw error;
      }

      toast.success('Incidente atualizado com sucesso!');
      await fetchIncidents();
    } catch (err) {
      console.error('Error updating incident:', err);
      const message = err instanceof Error ? err.message : 'Erro ao atualizar incidente';
      toast.error(message);
      throw err;
    }
  };

  const deleteIncident = async (id: string) => {
    try {
      const { error } = await supabase
        .from('incidents')
        .delete()
        .eq('id', id);

      if (error) {
        throw error;
      }

      toast.success('Incidente removido com sucesso!');
      await fetchIncidents();
    } catch (err) {
      console.error('Error deleting incident:', err);
      const message = err instanceof Error ? err.message : 'Erro ao remover incidente';
      toast.error(message);
      throw err;
    }
  };

  useEffect(() => {
    fetchIncidents();
  }, [status, severity, searchTerm, limit, offset]);

  return {
    incidents,
    loading,
    error,
    totalCount,
    createIncident,
    updateIncident,
    deleteIncident,
    refetch: fetchIncidents
  };
};